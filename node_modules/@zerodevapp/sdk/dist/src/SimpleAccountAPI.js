"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleAccountAPI = void 0;
const ethers_1 = require("ethers");
const contracts_1 = require("@zerodevapp/contracts");
const utils_1 = require("ethers/lib/utils");
const BaseAccountAPI_1 = require("./BaseAccountAPI");
const simpleAccountExecuteBatch_1 = require("./simpleAccountExecuteBatch");
/**
 * An implementation of the BaseAccountAPI.
 * - Pass "owner" address and "index" nonce to the factory
 * - owner signs requests using normal "Ethereum Signed Message" (ether's signer.signMessage())
 * - nonce is a public variable "nonce"
 * - execute method is "execTransactionFromModule()", since the entrypoint is set as a module
 */
class SimpleAccountAPI extends BaseAccountAPI_1.BaseAccountAPI {
    constructor(params) {
        var _a;
        super(params);
        this.factoryAddress = params.factoryAddress;
        this.index = (_a = params.index) !== null && _a !== void 0 ? _a : 0;
    }
    async _getAccountContract() {
        if (this.accountContract == null) {
            this.accountContract = contracts_1.SimpleAccount__factory.connect(await this.getAccountAddress(), this.provider);
        }
        return this.accountContract;
    }
    /**
     * return the value to put into the "initCode" field, if the account is not yet deployed.
     * this value holds the "factory" address, followed by this account's information
     */
    async getAccountInitCode() {
        return (0, utils_1.hexConcat)([
            await this.getFactoryAddress(),
            await this.getFactoryAccountInitCode()
        ]);
    }
    async getFactoryAddress() {
        if (this.factoryAddress != null) {
            return this.factoryAddress;
        }
        throw new Error('no factory address');
    }
    async getFactoryAccountInitCode() {
        const ownerAddress = await this.owner.getAddress();
        if (this.factory == null) {
            if (this.factoryAddress != null && this.factoryAddress !== '') {
                this.factory = contracts_1.SimpleAccountFactory__factory.connect(this.factoryAddress, this.provider);
            }
            else {
                throw new Error('no factory to get initCode');
            }
        }
        return this.factory.interface.encodeFunctionData('createAccount', [
            ownerAddress,
            this.index
        ]);
    }
    async getNonce() {
        if (await this.checkAccountPhantom()) {
            return ethers_1.BigNumber.from(0);
        }
        const accountContract = await this._getAccountContract();
        return await accountContract.nonce();
    }
    /**
     * encode a method call from entryPoint to our contract
     * @param target
     * @param value
     * @param data
     */
    async encodeExecute(target, value, data) {
        const accountContract = await this._getAccountContract();
        return accountContract.interface.encodeFunctionData('execute', [
            target,
            value,
            data
        ]);
    }
    async encodeExecuteBatch(calls) {
        const accountContract = await this._getAccountContract();
        const { dest, func } = (0, simpleAccountExecuteBatch_1.getExecBatchParams)(calls);
        const simpleAccount = new ethers_1.Contract(this.accountAddress, [
            'function executeBatch(address[] calldata dest, bytes[] calldata func)',
        ], accountContract.provider);
        return simpleAccount.interface.encodeFunctionData('executeBatch', [
            dest,
            func
        ]);
    }
    async signUserOpHash(userOpHash) {
        return await this.owner.signMessage((0, utils_1.arrayify)(userOpHash));
    }
    async encodeExecuteDelegate(target, value, data) {
        throw new Error('encodeExecuteDelegate not implemented');
    }
}
exports.SimpleAccountAPI = SimpleAccountAPI;
//# sourceMappingURL=SimpleAccountAPI.js.map