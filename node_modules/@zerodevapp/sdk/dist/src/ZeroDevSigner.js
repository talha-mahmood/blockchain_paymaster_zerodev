"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZeroDevSigner = exports.AssetType = void 0;
const properties_1 = require("@ethersproject/properties");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const ethers_eip712_1 = require("ethers-eip712");
const ethers_1 = require("ethers");
const BaseAccountAPI_1 = require("./BaseAccountAPI");
const types_1 = require("./types");
const utils_1 = require("ethers/lib/utils");
const utils_2 = require("./utils");
const MoralisApiService_1 = __importDefault(require("./services/MoralisApiService"));
var AssetType;
(function (AssetType) {
    AssetType[AssetType["ETH"] = 1] = "ETH";
    AssetType[AssetType["ERC20"] = 2] = "ERC20";
    AssetType[AssetType["ERC721"] = 3] = "ERC721";
    AssetType[AssetType["ERC1155"] = 4] = "ERC1155";
})(AssetType = exports.AssetType || (exports.AssetType = {}));
class ZeroDevSigner extends abstract_signer_1.Signer {
    // TODO: we have 'erc4337provider', remove shared dependencies or avoid two-way reference
    constructor(config, originalSigner, zdProvider, httpRpcClient, smartAccountAPI) {
        super();
        this.config = config;
        this.originalSigner = originalSigner;
        this.zdProvider = zdProvider;
        this.httpRpcClient = httpRpcClient;
        this.smartAccountAPI = smartAccountAPI;
        (0, properties_1.defineReadOnly)(this, 'provider', zdProvider);
    }
    // This one is called by Contract. It signs the request and passes in to Provider to be sent.
    async sendTransaction(transaction, executeBatchType = BaseAccountAPI_1.ExecuteType.EXECUTE) {
        var _a, _b, _c, _d, _e;
        // `populateTransaction` internally calls `estimateGas`.
        // Some providers revert if you try to call estimateGas without the wallet first having some ETH,
        // which is going to be the case here if we use paymasters.  Therefore we set the gas price to
        // 0 to ensure that estimateGas works even if the wallet has no ETH.
        if (transaction.maxFeePerGas || transaction.maxPriorityFeePerGas) {
            transaction.maxFeePerGas = 0;
            transaction.maxPriorityFeePerGas = 0;
        }
        else {
            transaction.gasPrice = 0;
        }
        const gasLimit = await transaction.gasLimit || await this.estimateGas(Object.assign({}, transaction), executeBatchType);
        const target = (_a = transaction.to) !== null && _a !== void 0 ? _a : '';
        const data = (_c = (_b = transaction.data) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : '0x';
        const value = transaction.value;
        const maxFeePerGas = transaction.maxFeePerGas;
        const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas;
        let userOperation;
        userOperation = await this.smartAccountAPI.createSignedUserOp({
            target,
            data,
            value,
            gasLimit,
            maxFeePerGas,
            maxPriorityFeePerGas
        }, executeBatchType);
        const transactionResponse = await this.zdProvider.constructUserOpTransactionResponse(userOperation);
        // Invoke the transaction hook
        let from, to;
        from = transaction.from;
        to = transaction.to;
        (_e = (_d = this.config.hooks) === null || _d === void 0 ? void 0 : _d.transactionStarted) === null || _e === void 0 ? void 0 : _e.call(_d, {
            hash: transactionResponse.hash,
            from,
            to,
            value: value !== null && value !== void 0 ? value : 0,
            sponsored: userOperation.paymasterAndData !== '0x',
            module: (0, types_1.getModuleInfo)(transaction)
        });
        try {
            await this.httpRpcClient.sendUserOpToBundler(userOperation);
        }
        catch (error) {
            // console.error('sendUserOpToBundler failed', error)
            throw this.unwrapError(error);
        }
        // TODO: handle errors - transaction that is "rejected" by bundler is _not likely_ to ever resolve its "wait()"
        return transactionResponse;
    }
    unwrapError(errorIn) {
        var _a;
        if (errorIn.body != null) {
            const errorBody = JSON.parse(errorIn.body);
            let paymasterInfo = '';
            let failedOpMessage = (_a = errorBody === null || errorBody === void 0 ? void 0 : errorBody.error) === null || _a === void 0 ? void 0 : _a.message;
            if ((failedOpMessage === null || failedOpMessage === void 0 ? void 0 : failedOpMessage.includes('FailedOp')) === true) {
                // TODO: better error extraction methods will be needed
                const matched = failedOpMessage.match(/FailedOp\((.*)\)/);
                if (matched != null) {
                    const split = matched[1].split(',');
                    paymasterInfo = `(paymaster address: ${split[1]})`;
                    failedOpMessage = split[2];
                }
            }
            const error = new Error(`The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo})`);
            error.stack = errorIn.stack;
            return error;
        }
        return errorIn;
    }
    async estimateGas(transaction, executeBatchType = BaseAccountAPI_1.ExecuteType.EXECUTE) {
        var _a, _b, _c;
        const tx = await (0, properties_1.resolveProperties)(this.checkTransaction(transaction));
        let userOperation;
        userOperation = await this.smartAccountAPI.createUnsignedUserOp({
            target: (_a = tx.to) !== null && _a !== void 0 ? _a : '',
            data: (_c = (_b = tx.data) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : '0x',
            value: tx.value,
            maxFeePerGas: tx.maxFeePerGas,
            maxPriorityFeePerGas: tx.maxPriorityFeePerGas
        }, executeBatchType);
        const gasInfo = await this.httpRpcClient.estimateUserOpGas(Object.assign(Object.assign({}, userOperation), { 
            // random dummy signature, because some bundlers (e.g. StackUp's)
            // require that the signature length is correct, in order to estimate
            // preverification gas properly.
            signature: '0x4046ab7d9c387d7a5ef5ca0777eded29767fd9863048946d35b3042d2f7458ff7c62ade2903503e15973a63a296313eab15b964a18d79f4b06c8c01c7028143c1c' }));
        return ethers_1.BigNumber.from(gasInfo.preVerificationGas).add(ethers_1.BigNumber.from(gasInfo.verificationGas)).add(ethers_1.BigNumber.from(gasInfo.callGasLimit));
    }
    async getUserOperationReceipt(hash) {
        return await this.httpRpcClient.getUserOperationReceipt(hash);
    }
    async verifyAllNecessaryFields(transactionRequest) {
        if (transactionRequest.to == null) {
            throw new Error('Missing call target');
        }
        if (transactionRequest.data == null && transactionRequest.value == null) {
            // TBD: banning no-op UserOps seems to make sense on provider level
            throw new Error('Missing call data or value');
        }
    }
    connect(provider) {
        throw new Error('changing providers is not supported');
    }
    async getAddress() {
        if (this.address == null) {
            this.address = await this.zdProvider.getSenderAccountAddress();
        }
        return this.address;
    }
    async signMessage(message) {
        const dataHash = ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.hashMessage(message));
        let sig = (0, utils_2.fixSignedData)(await this.originalSigner.signMessage(dataHash));
        // If the account is undeployed, use ERC-6492
        if (await this.smartAccountAPI.checkAccountPhantom()) {
            const coder = new ethers_1.ethers.utils.AbiCoder();
            sig = coder.encode(['address', 'bytes', 'bytes'], [
                await this.smartAccountAPI.getFactoryAddress(),
                await this.smartAccountAPI.getFactoryAccountInitCode(),
                sig
            ]) + '6492649264926492649264926492649264926492649264926492649264926492'; // magic suffix
        }
        return sig;
    }
    async signTypedData(typedData) {
        const digest = ethers_eip712_1.TypedDataUtils.encodeDigest(typedData);
        return await this.signMessage(digest);
    }
    async _signTypedData(domain, types, value) {
        const message = utils_1._TypedDataEncoder.getPayload(domain, types, value);
        return await this.signTypedData(message);
    }
    async signTransaction(transaction) {
        throw new Error('not implemented');
    }
    async signUserOperation(userOperation) {
        const message = await this.smartAccountAPI.getUserOpHash(userOperation);
        return await this.originalSigner.signMessage(message);
    }
    async getExecBatchTransaction(calls, options) {
        const calldata = await this.smartAccountAPI.encodeExecuteBatch(calls);
        return Object.assign(Object.assign({}, options), { data: calldata });
    }
    async execBatch(calls, options) {
        const transaction = await this.getExecBatchTransaction(calls, options);
        return await this.sendTransaction(transaction, BaseAccountAPI_1.ExecuteType.EXECUTE_BATCH);
    }
    async listAssets() {
        const moralisApiService = new MoralisApiService_1.default();
        const chainId = await this.getChainId();
        const address = await this.getAddress();
        const assets = [];
        const nativeAsset = await moralisApiService.getNativeBalance(chainId, address);
        if (nativeAsset !== undefined)
            assets.push(nativeAsset);
        const tokenAssets = await moralisApiService.getTokenBalances(chainId, address);
        if (tokenAssets !== undefined)
            assets.push(...tokenAssets);
        const nftAssets = await moralisApiService.getNFTBalances(chainId, address);
        if (nftAssets !== undefined)
            assets.push(...nftAssets);
        return assets;
    }
    async transferAllAssets(to, assets, options) {
        const selfAddress = await this.getAddress();
        const calls = assets.map(async (asset) => {
            switch (asset.assetType) {
                case AssetType.ETH:
                    return {
                        to,
                        value: asset.amount ? asset.amount : await this.provider.getBalance(selfAddress),
                        data: '0x'
                    };
                case AssetType.ERC20:
                    const erc20 = (0, utils_2.getERC20Contract)(this.provider, asset.address);
                    return {
                        to: asset.address,
                        value: 0,
                        data: erc20.interface.encodeFunctionData('transfer', [to, asset.amount ? asset.amount : await erc20.balanceOf(selfAddress)])
                    };
                case AssetType.ERC721:
                    const erc721 = (0, utils_2.getERC721Contract)(this.provider, asset.address);
                    return {
                        to: asset.address,
                        value: 0,
                        data: erc721.interface.encodeFunctionData('transferFrom', [selfAddress, to, asset.tokenId])
                    };
                case AssetType.ERC1155:
                    const erc1155 = (0, utils_2.getERC1155Contract)(this.provider, asset.address);
                    return {
                        to: asset.address,
                        value: 0,
                        data: erc1155.interface.encodeFunctionData('safeTransferFrom', [selfAddress, to, asset.tokenId, asset.amount ? asset.amount : await erc1155.balanceOf(selfAddress, asset.tokenId), '0x'])
                    };
            }
        });
        const awaitedCall = await Promise.all(calls);
        return await this.execBatch(awaitedCall, options);
    }
}
exports.ZeroDevSigner = ZeroDevSigner;
//# sourceMappingURL=ZeroDevSigner.js.map